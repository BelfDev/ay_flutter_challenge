import 'package:ay_flutter_challenge/blocs/blocs.dart';
import 'package:ay_flutter_challenge/blocs/contact/contact_bloc.dart';
import 'package:ay_flutter_challenge/data/repositories/contact_repository.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

class _MockContactRepository extends Mock implements ContactRepository {}

void main() {
  _MockContactRepository contactRepository;
  ContactBloc contactBloc;

  setUp(() {
    contactRepository = _MockContactRepository();
    contactBloc = ContactBloc(contactRepository);
  });

  tearDown(() {
    contactRepository = null;
    contactBloc = null;
  });

  // TODO: Understand how to expect emissions generated by [StateQueue]'s inner run bloc and complete test cases
  group('ContactBloc', () {
    test('initial state is ContactState.initial', () {
      expect(contactBloc.value, ContactState.initial());
    });

    test('.requestContactSections() emits ContactState.loading', () {
//      // Forces the hasCache flag to be false
//      when(contactRepository.hasCache).thenAnswer((_) => false);
//
//      contactBloc.requestContactSections();
//
//      expectLater(contactBloc.value, emits([ContactState.loading([])]));
    });

    test(
        '.requestContactSections() emits ContactState.loading with empty contacts',
        () {});

    test(
        '.requestContactSections() emits ContactState.loading with cached contacts',
        () {});

    test('.requestContactSections() emits ContactState.success with sections',
        () {});

    test('.requestContactSections() emits ContactState.error', () {});
  });
}
